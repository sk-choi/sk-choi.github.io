---
title : "컴퓨터 네트워크 03 - 데이터 링크 계층(Data Link Layer)"
date : 2023-07-16 18:29:47 +/-TTTT
categories : 
- Computer_Network
tags : 
- [네트워크] #소문자만 가능
published : true
#permalink : categories/computer_network

toc: true
toc_sticky: true
---

# Intro 

이 글은 컴퓨터 네트워크의 OSI 7 layer기준으로 제 2계층인 데이터 링크 계층에 대해 다룹니다.

------

# 프로토콜과 프레임

**프로토콜:** 데이터 전송 시 필요한 규칙, 형식과 절차가 모두 정의된 것   
**프레임:** 데이터 링크 계층에서 데이터를 보내고 데이터를 받을 때 사용하는 기본 단위    
데이터 링크 계층에서는 프레임을 기본 단위로 해서 데이터를 전송함   
entity는 데이터 통신과 관련한 기기를 말한다.    
프로토콜에 들어가는 규칙은 **(1)데이터 포맷**, **(2)타이밍**, **(3)동작** 등이 포함된다.(무엇을 언제 어떻게 보내느냐?에 대한 정의)   

-----

# OSI 모델의 계층
osi 모델: 7계층으로 이루어져 있음.    
개념적으로는 n계층은 n계층끼리 전송함. 사실은 밑의 계층을 통해서 전송됨   

![img](https://blogfiles.pstatic.net/MjAyMTAxMDhfNTUg/MDAxNjEwMDQwMjI2NzE0.VqKrhuEPNuVBA-3vO9dGUpwL-Ip4uHdZFyJDoBG-BMMg.Hxn1h8hIV_JuMXbAl56GSAJ1ZjSYMdlwitA1ZI1inX0g.PNG.cometrue0319/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7_2021-01-08_%EC%98%A4%EC%A0%84_2.23.19.png?type=w1)


**SDU:** 서비스 데이터 유닛, 서비스를 제공하기 위한 데이터 단위   
**PDU:** 프로토콜 데이터 유닛, 프로토콜을 포함한 데이터 유닛   
4계층의 pdu는 3계층의 sdu가 됨. **sdu + pci = pdu**       
**SAP:** 서비스 어세스 포인트, 모든 계층 간의 통신(1-2, 2-3, 3-4 등), 데이터 전송은 이 곳에서 이루어진다.   
osi의 계층은 7개의 계층으로 이루어져 있음. 통신에 필요한 것을 역할 별로 나누어서 7가지로 나눔.    
-> osi 7 layered reference model: ~~이 모델을 참조해서 네트워크 모델을 만들어라!~~   

![img](https://blogfiles.pstatic.net/MjAyMTAxMDhfMjk4/MDAxNjEwMDM5ODE2NzU2.GUpFWowhAgWC18CeX7X7i2nxizMlc-_83i4cwo_bWMUg.Wb8bxDZ4O_jpEenXkV4OjG6GeckfCAOGpnLFcWsZ6iwg.PNG.cometrue0319/%EB%8B%A4%EC%9A%B4%EB%A1%9C%EB%93%9C.png?type=w1)

**제 1계층(물리계층):** 기계적이고 전기적인 것을 정의 함. 커넥터도 정의 함(osi에서 실제로 정의되어 있지는 않음, 정의해라 정도의 의미)    

**제 2계층(데이터 링크 계층):** 물리적으로 연결 된 두 개의 노드(이웃 간 노드) 사이의 신뢰성 있는 데이터 전송을 보장하는 것을 함. 물리 계층에서는 데이터 전송에 장애가 있는 것을 인지하지 못함. 그래서 2계층에서는 노이즈로 인한 데이터 깨짐을 인지하고 검출 및 수정하는 일을 함.    
가장 중요한 일: 같은 미디어를 두 개 이상의 노드가 공유할 경우에는 한 사람만 이 미디어를 사용할 수 있게 보장해주어야 함. (mac: media access control)   
+ 흐름제어: 데이터 전송 시에 준비가 되어 있지 않으면 데이터 전송을 완전히 처리해 줄 수 없음. 그래서 전송 속도나 여러 상황을 제어하는 기능이 필요한데 이것이 흐름제어어의 역할이라 할 수 있다.   
1. 데이터의 프레임화   
2. 프레임의 순서 제어   
3. 프레임의 전송 확인과 흐름 제어   
4. 오류 검출 및 복원   

**제 3계층(네트워크 계층):** 길을 찾는 기능, 서브넷을 관리(패킷을 보내기 위해 경로를 찾는 일)    

**제 4계층(트랜스포트 레이어):** 엔드 투 엔드, 사용자 간 신뢰성 있는 데이터 전송을 위한 계층    
카톡이 안전하게 친구에게 도달하는 것은 4계층이 보장해 준다.    

**제 5계층(세션 레이어):** 사용자 간 연결을 잘 관리해주는 것을 관리    
ex. 수강신청 시에 로그인한 상태를 유지시켜주는 것     

**제 6계층(프레젠테이션 레이어):** 보여주는 역할, 데이터를 보여주고 암호화 및 해석화 해주는 역할    

**제 7계층(응용 계층):** 웹 브라우저와 같은 서비스     

tcp/ip 모델에서는 3계층이 ip, 4계층이 tcp, 나머지 5,6,7 계층이 응용계층으로 섞여 있음     

여기서는 2계층(데이터 링크 계층)에 대해 자세히 다룬다.
-------------------

# 채널 얼로케이션

채널 얼로케이션(allocation): 미디어를 어떤 특정 노드가 사용할 수 있게끔 할당하는 것

스태틱(static) 채널 얼로케이션: 한 번 정해놓으면 바뀌지 않음   
다이나믹(dynamic) 채널 얼로케이션: 계속 바뀜   

채널 하나를 여러개의 스테이션이 사용하고 싶을 경우   
데이터를 동시에 보낼 경우 충돌이 발생하는 것을 알 수 있는 경우   
남이 데이터를 보내면 데이터를 보낸다는 것을 알 수 있는 경우(반송파(carrier)로 파악)   

-----------

# 맥 레이어/로지컬 링크 컨트롤 레이어

데이터 링크 계층은 크게 봤을 때 두 가지로 나뉜다.      
1. MAC: Media Access Control      
2. LLC: Logical Link Control   

MAC은 어떻게 프레임을 전송할 것인지 정의하는 것.
LLC는 프로토콜을 식별하여 연결을 유지하는 기능 수행.

------------------

# 맥 프로토콜의 종류(알로하, slotted ALOHA, CS, MA, CD, Collision free)

![img](https://static.javatpoint.com/difference/images/pure-aloha-vs-slotted-aloha.png)

통신에서 가장 기본적인 맥 프로토콜: **알로하 프로토콜**(네 개의 섬에 있는 캠퍼스 간에 무선통신을 위한 프로토콜, 내가 데이터를 보내고 싶을 때 데이터를 보냄)
운이 좋으면 전달 되는 것이고 안되면 어쩔 수 없는 것임. (이 문제는 LLC가 담당)
모든 패킷의 길이는 같다. (항상 같은 길이의 데이터를 보냄)
데이터를 보내는데 t 만큼의 시간 필요. 그래서 패킷이 정상적으로 전송되기 위해선 +t 혹은 -t 만큼의 시간 필요.
그렇기에 2t 동안의 시간 동안 다른 노드가 데이터를 보내지 않아야 내 데이터가 무사히 전송됨.     
람다(도착할 확률): 0.18 (100mbps 중에서 18mbps만 사용가능)

![img](https://static.javatpoint.com/difference/images/pure-aloha-vs-slotted-aloha2.png)

**slotted ALOHA protocol:** 알로하 프로토콜의 개선된 버전. 시간을 특정 단위로 쪼개서 어떤 사람도 그 시간대 데이터를 보내지 못하고 다음 시간대에 보내야 한다.    
이 프로토콜에서는 한 시간대에 두 개 이상의 노드가 데이터를 보내려고 하면 충돌이 발생.(1t에서 충돌이 발생할 확률로 감소, 절반으로 감소)     
결국 약 0.37로 확률이 두 배만큼 증가한다.    

**캐리어 센스(Carrier Sense, CS):** 이더넷 환경에서 통신을 하고 싶은 PC나 서버는 먼저 지금 네트워크 상에 통신이 일어나고 있는지를 확인한다. 즉 우리가 자원을 쓰고 있는 PC나 서버가 있는지를 확인해 보는 것. 이것을 '캐리어(반송파)'라 하는데 캐리어를 감지하는 것을 '캐리어 센스(Carrier Sense)'라 함. 

**멀티플 액세스(Multiple Access):** 다른 노드에서 데이터 통신이 발생하는지 계속해서 보는 것. (계속해서 보는 방법과 띄엄띄엄 보는 방법으로 나뉨)    
계속해서 보는 방법의 경우 데이터 전송이 끝나자마자 다른 두 노드가 동시에 데이터를 전송하려다 충돌이 발생할 수 있다. 결국엔 확률적인 문제. 

**CD(Collision Detection):** 컬리젼(충돌)이 발생하면 데이터 전송을 중지함.    
데이터 전송을 중지하고 다음 전송 전까지 기다리는 시간은 랜덤으로 정해진다. 충돌이 발생하고 랜덤 시간으로 대기할 때 마다 다음 기다리는 시간은 두 배씩 들어난다.
(Binary exponential back-off Algorithm)   

**collision free protocol:** 
1. 처음에 n개의 노드가 있을 경우, 데이터 전송 순서를 정한 다음 데이터 전송을 하고 그 다음에도 마찬가지로 순서를 정해서 데이터 전송을 하게 한다.   

2. 데이터를 전송할 노드에서 제일 처음에 자신의 주소를 보내는데 주소가 제일 상위비트인 노드부터 먼저 보내고 하위비트인 노드는 나중에 보내는 식으로 데이터 전송 순서를 정한다.   

------------

# 프레이밍, 에러 컨트롤, 플로우 컨트롤, 스터핑

네트워크는 7계층으로 이루어져 있다. 데이터 링크 계층에서 하는 일은 이웃 노드 간 안전한 데이터 전송을 하는 것이다.
여기서 작동하는 주요 개념이 바로 프레이밍, 에러 컨트롤, 플로우 컨트롤, 심플렉스(단방향 통신), 듀플렉스(양방향통신: 하프-듀플렉스, 풀-듀플렉스)이다.

**누가 데이터를 보내고 누가 받을 것인가? - 플로우 컨트롤**
**보낼 데이터를 적당한 크기로 나누는 것 - 프레이밍**   
**데이터 전송과정에서 발생하는 오류를 감지하고 수정하는 것 - 에러 컨트롤**   

3계층에서 데이터 패킷을 만들고 그것을 데이터 링크 계층으로 보내면 페이로드(payload: 전송되는 순수한 데이터)가 된다.   
거기에 헤드와 트레일러가 붙으면 '프레임'이라는 단위가 된다.   
프레임을 만들면 제 1계층을 통해 전송되고 2계층에서는 헤더와 트레일러를 통해 에러 컨트롤, 플로우 컨트롤을 처리하고 문제가 없으면 3계층으로 전송된다.   

![img](https://media.geeksforgeeks.org/wp-content/cdn-uploads/1-30.png)

**프레이밍(Framing)**: 데이터를 나누는 것. 2계층에서 보낼 수 있는 단위로 나누는 것.   
어떻게 프레임을 나눌 것인가에 대한 약속이 바로 프레이밍이다. 데이터를 받았는데 어떻게 나눌지 모른다면 문제가 발생하기 때문이다.   
그래서 내가 보낼 데이터를 얼마나 보낼 것인지 미리 알려주는 방법으로 문제를 해결한다. -> (캐릭터 카운트(Character count))   

문제는 에러가 발생할 경우인데, 캐릭터 카운트를 전송할 때 오류가 발생하게 되면 복구가 불가능한 에러가 발생하게 된다. 현실에서는 앞과 뒤를 알려주는 특수한 문자(플래그)를 알려준다.
하지만 만약 내가 보내는 데이터 가운데에 플래그에 사용된 문자가 똑같이 있으면 받는 쪽에서는 그 플래그만을 보고 데이터 수신을 멈출 수 있다. 그래서 그 플래그 이후의 데이터를 무시할 수 있는 가능성이 생긴다.    
그래서 데이터를 보낼 때 데이터 안에 플래그와 똑같은 문자가 있을 시 그 문자 앞에 특수한 문자를 덧붙여서 데이터를 보낸다.   
ex. 만약 플래그에 ‘5’가 있는데 데이터 가운데에 똑같이 ‘5’가 있으면 ‘5’앞에 ‘3’을 덧붙여서 데이터를 전송한다.   

이와 같이 데이터를 보낼 때 플래그를 사용해 처음과 끝을 알려주는 것을 **스터핑(Stuffing)**이라고 한다. 그리고 문자를 사용해 스터핑을 하는 것을 **Byte-Stuffing**이라고 한다.   
좀 더 빠르게 데이터를 보내기 위해서 데이터를 문자 단위로 나누지 않고 전체 데이터를 비트 시퀀스로 생각해 보내는 방식도 존재한다.
데이터를 보내기 위해 비트로 만들어진 플래그를 보내고 데이터를 보낸 후 데이터 전송 완료 플래그를 또 보내는 방식이다.   
하지만 우연히 데이터 안에 플래그와 똑같은 데이터가 있다면 수신 측에서는 이것을 발견하는 순간 수신을 종료하게 된다. 그래서 보내는 측에서는 플래그에 1이 다섯 개가 있을 경우 데이터에도 1이 다섯 개 있으면 다섯 개를 보낸 후에 무조건 0을 보내는 식으로 문제를 해결한다.   
(강제적으로 0을 삽입)->**Bit Stuffing**   
현재는 이러한 비트 스터핑 방식을 통해 프레이밍을 진행한다.   

# 에러 디텍션 코드, 플로우 컨트롤, ENQ/ACK 기법

**에러 디텍션 코드:** 원래 보내고자 하는 데이터에 미리 약속되어 있는 시퀀스를 같이 보냄으로서 같이 보낸 코드로 원래 데이터를 나누었을 때 발생하는 나머지가 일치하면 데이터에 문제가 없다는 판단을 하게 만든다. 중간에 데이터가 에러 날 경우 나머지가 0이 되지 않으므로 오류를 탐지할 수 있다. (CRC)    
CRC는 에러 발생만 알고 어디서 에러가 발생했는지는 모른다. 어디서 에러가 발생했는지 아는 코드가 바로 **해밍코드(Hamming Code)**이다. 기존 데이터에 다른 코드를 덧붙여서 어디서 오류가 발생했는지 알 수 있음.   
실제 데이터에 추가적으로 데이터를 덧붙이는 것이므로 비효율적이며, 저속으로 데이터를 보내는 경우에 자주 사용하고 고속으로 데이터를 보내는 경우에는 사용하지 않는다.   

![img](https://www.scaler.com/topics/images/flow-control-and-error-control_thumbnail.webp)

**플로우 컨트롤:** 데이터를 보내는 쪽에서는 한 번에 데이터를 많이 보내고 싶은데 데이터를 받는 쪽에서는 그걸 빠르게 처리할 수 없으므로 받는 쪽에서는 버퍼가 발생하게 된다. 받는 쪽에서 데이터를 처리하는 속도가 느리다면 데이터를 받는 쪽에 맞추어 천천히 데이터를 보낸다.  

![img](https://blog.kakaocdn.net/dn/dNXq6S/btq1FB5uflc/r1BlOvL8RdaB20LBp2FvZK/img.png)

**ENQ/ACK 기법:** 데이터를 보낼 때 먼저 상대방 쪽에 ENQ를 보내고 상대방 쪽에서 오는 ACK를 확인하고 보내기 때문에 상대방의 속도에 맞추어 데이터를 전송할 수 있다.   

데이터를 받는 쪽이 여러 스테이션(station)이라면?   
매스터가 있어서 각각의 스테이션에 물어보는 방식을 이용한다.   
**NACK(Negative-ACK):** 데이터를 받을 준비 혹은 보낼 준비가 안 되어있다. => 폴링기법   

-----------------------------

# 스탑 앤 웨이트, ARQ, 윈도우(Go Back N 방식)

스탑 앤 웨이트: 데이터를 보내고 기다리면서 전송 속도를 맞추는 방식, 하지만 효율성(속도)가 떨어지는 단점이 존재한다.   
효율성을 높이기 위해 등장한 방법이 바로 ARQ 방식이다.   

![img](https://learnlearn.uk/igcsecs/wp-content/uploads/sites/23/2021/03/Stop-and-wait-ARQ-1.jpg)

**ARQ(Automatic Repeat Request) 방식:** 데이터를 보낼 때 에러가 발생하면 상대방 측에서 에러가 발생했다는 신호를 전송측에 보내고 에러가 난 부분만 다시 보내주는 방식
상대방에게 데이터를 1을 보내면 상대방 측에서 데이터를 받고 ACK를 보냄.   
만약 10이라는 데이터를 보내는데 상대방 측에서 NACK가 오면 이 데이터를 다시 보내는 것이다.   
만약 데이터 전체가 제대로 전송이 안 될 경우 ACK가 전송도 안된다. 그래서 전송하는 측에서는 일정시간을 기다리면서 ACK가 오지 않을 경우 다시 데이터를 전송하는 방법을 사용한다.   
(이것도 스탑 앤 웨이트 방식이라 효율이 떨어짐.)   
그래서 받는 쪽에 일정 데이터를 저장할 수 있는 버퍼를 놓고 전송 측에서 버퍼 사이즈에 맞는 데이터를 전송할 수 있게 함.   

![img](https://blog.kakaocdn.net/dn/5Bsbb/btqVV4gmqAU/trOi1j9XJxuqcHsNurkbjK/img.png)

**윈도우:** 전송 또는 수신 측에서 만든 버퍼의 사이즈. (버퍼 크기와 같을 수도 작을 수도 있음)   
창문을 여는 것과 비슷하다. 창문을 열면 벽 전체가 열리는 것이 아니라 일부분만 열리는 것처럼 버퍼 크기의 일부만 받는다는 것이다.   
버퍼의 크기가 7인 경우 3의 데이터를 이미 보냈다면 4의 크기 정도만 보낼 수 있음.   
스탑 앤 웨이트 방식보다 효율적이다.    
보내는 쪽에서 01A0이라는 데이터를 보낼 때 이것을 잘 받으면 0번에 대해서 잘 받았다는 신호를 줌. 그러면 보내는 쪽에서 1에 대한 데이터를 보내고 A0에 대한 데이터를 보내면 받는 쪽에서는 1번에 대해 제대로 받고 1에 대한 응답을 줌.
받는 쪽에서 시간 안에 응답이 오지 않으면 응답이 오지 않은 부분에 대해서 다시 데이터를 보냄. (고 백 엔(Go Back N)방식)   

1. 에러가 난 것 하나에 대해서만 다시 데이터를 보내는 것: Selective repeat 방식(효율성 높음, 유지 관리 쉽지 않음, 에러 난 부분을 다시 맞춰야 하기 때문)   
2. 에러가 난 이후의 받은 것들을 다 폐기하고 새로 받는 것: 고 백 엔 방식(효율성 다소 떨어짐)   
3. 데이터를 보내고 대기하면서 데이터를 전송: 스탑 앤 웨이트 (효율성 많이 떨어짐)   
