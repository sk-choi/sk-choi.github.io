---

title : "컴퓨터 네트워크 06 - 세션 계층(session Layer)과 IP"
date : 2023-07-24 14:12:35 +/-TTTT
categories : 
- Computer_Network
tags : 
- [네트워크] #소문자만 가능
published : true
#permalink : categories/computer_network

header :
  teaser : https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Ft1.daumcdn.net%2Fcfile%2Ftistory%2F2405164258FDB98020

toc: true
toc_sticky: true
sidebar:
    nav: "sidebar-category"
---
# Intro   

이 글은 OSI 7 layer 중 5계층인 세션 레이어와 인터넷 프로토콜인 IP에 대해서 다룹니다.

-----

# 세션 레이어, 프레젠테이션 레이어, 어플리케이션 레이어     

5계층은 세션 레이어, 7계층은 프레젠테이션 계층임, 어플리케이션은 응용계층이다. 그런데 이 세 계층이 아주 완벽하게 나뉘어지는 것은 힘들다. 왜냐하면 응용 계층이 프레젠테이션 계층이 하는 것을 하는 경우가 있기 때문이다. (그런 경우가 많다.)    
그래서 세션 레이어와 응용계층 프레젠테이션 계층이 하나로 묶여서(어플리케이션 계층 안에서) 사용되는 경우가 많은데, TCP/IP의 경우 4계층에 해당되고 세션, 응용, 프레젠테이션 계층을 처리한다.   
IP는 3계층에 해당하고, TCP는 4계층에 해당한다. TCP는 버클리 대학에서 개발되었다. 그리고 이걸 오픈 소스로 공개하여 누구나 개발할 수 있도록 만들어졌다.    
70년대에 네트워크 프로토콜로 TCP/IP가 채택되었다. 오픈소스인 유닉스, IBM PC 계열(소형 컴퓨터)에서 사용되었다.(드펙토(de facto) 프로토콜)    

5, 6, 7계층이 하나로 묶여 응용계층에 해당된다. 4계층에는 TCP외에 UDP도 포함되어 있다.      

------

# IP    

![img](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Ft1.daumcdn.net%2Fcfile%2Ftistory%2F2405164258FDB98020)

IP는 인터넷 프로토콜(Internet Protocol)의 약자이다. ip주소를 활용하여 여러 컴퓨터에 데이터를 정보를 전달하는데 활용되는 프로토콜이다.     
4계층에서 데이터가 만들어지면, 3계층으로 그 세그먼트를 내려보내고 그게 3계층에서는 페이로드가 되어 거기에 컨트롤 프로토콜을 붙여 ‘패킷’을 만들게 된다. 여기에 2계층에서 하나의 프로토콜을 붙이면 하나의 ‘프레임’이 된다.    

IP 계층에서는 데이터에 IP헤더(header)를 붙인다. TCP 계층에서 내려온 데이터에 IP헤더를 붙이는데 기본적으로 20바이트, 많으면 60바이트, 전체길이는 최대 64바이트까지 구성된다.   
제일 먼저 부여되는 것이 IP버전 넘버이다. 보통 IP 버전 4이며, 그 다음에 나오는 4비트가 헤더렌스이다.(헤더의 길이), 헤더렌스는 기본적으로 4바이트(32비트)이다. 헤더렌스가 1이라고 하면 1바이트가 아니라 4바이트라는 것이다. 그래서 헤더렌스가 4라고 하면 4바이트가 아니라 16바이트라는 것이다. 

그 다음엔 DS(Tos: Type of Service)가 붙는데 이 패킷을 어떻게 다룰지에 대한 정보가 들어있다. D,T,R,C로 구성되어 있는데 D는 Delay를 의미하고 값이 1에 해당하면 딜레이를 최소한으로 하게 고려해달라고 하는 것이고(최소한의 경로로 라우팅 하라는 것) T는 Throughput(처리율)이고 R은 안전성(Reliability), C(Cost)는 비용최소이다. 제일 위에 있는 세 비트는 우선순위(Priority)를 의미한다. (이 패킷이 우선순위가 높은 것이냐 낮은 것이냐를 판별) 
그 다음에 나오는 16비트는 데이터의 전체 길이를 말한다.(64kb 안으로 데이터를 보낼 수 있다.) 
그 다음에 나오는 것은 식별자인데 이 패킷의 일련번호라고 할 수 있다. 16비트이므로 0부터 65345번까지 일련번호를 매겨서 보낸다. 16비트가 라운딩 되면서 시퀀스 넘버를 지정한다.    
그 다음엔 플래그인데, 이 패킷을 분할을 시킬 것인지 말 것인지에 대한 정보를 담고 있다. IP의 경우 보낼 수 있는 맥시멈의 크기가 64KB이기 때문에 매우 큰 용량의 데이터를 나눠서 보내게 되는데 DF(Don't fragment: 데이터를 나누지 말고 한꺼번에 보내라는 의미), MF(More fragment: 내 패킷 뒤에 또 다른 패킷이 전송된다는 의미)를 통해서 뒤에 또 다른 패킷이 오는지 알려준다.   

그 다음에 오는 것은 옵셋(13비트)인데, 하나의 패킷을 여러 개로 분할하여 보낼 경우에 지금 전송되는 패킷이 전체 패킷의 어느 부분에 해당하는지 알려준다.    
TTL(8비트)은 타임 투 라이브(time to live)를 의미하며, 라우터를 지날 때마다 TTL을 하나씩 지우게 되며 TTL이 0이 되면 데이터를 중간에 지워버린다. TTL이 100이면 중간에 라우터를 100개 거쳐서 목적지까지 도달할 수 있고 100을 넘어가면 중간에 데이터가 지워지게 되는 것이다.    
그 다음에 나오는 것이 프로토콜인데 IP계층 위의 계층에서 무슨 프로토콜을 사용하는지에 대한 정보를 알려준다.(Tcp 혹은 Udp 아니면 icmp 등등) 마지막으로는 헤더 체크섬(16비트)인데 지금까지 전송된 데이터에 오류가 있는지 확인하는 정보를 담고 있다. 그 다음에 나오는 32비트가 데이터를 보내는 쪽의 컴퓨터 주소, 다음 32비트는 데이터를 받는 쪽의 컴퓨터를 말한다.    

TOS(Type of service)코드: DTRC로 보낼 데이터를 어떻게 다룰지에 대한 정보를 나타냄.       
SMTP(명령)의 경우 메일을 보내기 위한 프로토콜인데, D 영역에 1이 할당됨으로서 지연시간이 최소화되도록 설정된다. SMTP(데이터)의 경우 첨부파일을 보내야 하므로 처리율을 높여야하므로 T를 1로 설정한다. 즉 어플리케이션 종류에 따라서 DTRC를 다르게 설정한다.     
TCP와 UDP를 많이 사용. 
플래그는 오류 검출을 위한 플래그와 다름. 데이터 분할을 위한 장치임.

--------------

# IP 어드레스      

![img](https://www.ipxo.com/app/uploads/2021/09/IPv4-anatomy.png)

각각 32비트, 데이터를 전송하는 컴퓨터의 주소, 데이터를 수신하는 주소.   
dotted decimal notation: 10진수로 표현된, 컴퓨터에 주소를 부여할 수 있는 체계, 4바이트를 각각 점으로 구분하는 표기 방식이다.    
점 하나당 8비트씩이므로 0~255까지의 값, 즉 0.0.0.0부터 255.255.255.255라는 40억개의 값을 가질 수 있다. 하지만 TCP/IP가 나올 당시의 시기는 70년대 초반이었는데, 이 당시에는 컴퓨터의 수가 지금처럼 기하급수적으로 많아질지 몰랐다.    
1.0.0.0부터 126.255.255.255까지의 주소는 A클래스 도메인에 해당하는데 IP주소에서 앞의 8비트는 네트워크 주소이고, 나머지 24비트는 컴퓨터의 주소에 해당한다. 그렇기에 A클래스의 네트워크를 사용할 수 있는 컴퓨터는 126개밖에 없다.    
129.0.0.0부터 사용할 수 있는 주소는 B클래스 도메인에 해당하는데, 이 B클래스 도메인을 사용할 수 있는 컴퓨터는 65456여 대만 해당한다. 전 세계에서 b클래스를 사용할 수 있는 기관은 16000여 곳 밖에 안 된다.   
C클래스는 256개의 컴퓨터가 해당된다. 네이버가 C클래스에 해당.   
ip주소 체계에서는 버려지는 아이피 주소가 많다. 40억개의 주소를 다 쓸 수 있는게 아니다. 그렇기에 이러한 주소체계는 불합리할 수밖에 없으며 이러한 문제를 ip v6로 해결하고 있다.   

**서브넷:** 네트워크를 하나의 그룹으로 만들어서 사용하는 것.   
아이피 주소에서 뒤의 16비트가 컴퓨터 주소를 의미하므로 그걸 가지고 몇 개의 그룹을 만들어 그룹핑을 통해 관리한다. 이러한 그룹핑이 바로 서브넷인 것이다. 0~63 즉 64개의 그룹핑으로 서브넷을 관리할 수 있다. 그렇다면 왜 서브넷을 만드는 것일까? 컴공과라면 컴공과 컴퓨터끼리 데이터 전송이 주로 이루어질 것이기에 서브넷을 통해 그룹핑을 하고, 게이트웨이를 통해 외부 서브넷끼리 네트워크를 이루도록 할 수 있게 만든 것이다. 즉 네트워크 사이즈를 줄임으로서 데이터를 분산시킬 수 있는 것이다. 결국 네트워크 관리가 편해지는 것이다.    

**서브넷 마스크:** 어느 부분까지가 네트워크 주소이고 어느 부분까지가 호스트 주소인지 구분할 수 있게 만드는 것.    
왜 서브넷 마스크가 중요한가? 서브넷이 같으면 인테리어 라우팅하면 되고 다르면 익스테리어 라우팅 하면 된다.    
아이피 주소는 임의대로 설정할 수 없다. 국제적으로 할당된 것만 사용할 수 있다. 아이피 마스커레이딩을 통해 아이피를 바꿀 수 있긴 함.    
그렇다면 무선공유기를 사용해서 여러 기기를 네트워크에 연결할 수 있는 이유는 무엇일까? 공인 아이피 주소를 요청한 적이 없는데 사용할 수 있는 이유는 NAT(Network Address Translation)을 통해 공유기가 ip주소를 변환시켜주기 때문이다. 아이피타임 같은 공유기가 NAT 프로토콜을 사용하고 있기 때문에 우리가 여러 ip주소를 사용할 수 있는 것이다.    
통신사로부터 할당받은 공인 아이피 주소를 집에서 사용할 수 있는 별도의 서브넷 주소로 할당해주는 게 무선공유기의 역할이다.     
ex. 192.168.0.4, 192.168.0.5 등     

위 주소는 B클래스에 해당하는 만큼 65000여대의 컴퓨터를 사용할 수 있는 ip주소이기도 하다. 이게 어떻게 가능할까? 포트번호라는 것이 있는데 192.168.0.5를 공인 아이피 주소로 변환시켜서 나가게 된다. 그럼 어떻게 구분을 하는가? 그렇기에 포트 번호를 추가적으로 할당하여 데이터를 받을 때 알맞은 주소로 전송되게 만든다.    
통신사에서 이를 기술적으로 막을 수는 있지만, 사용자 수의 감소를 우려하여 막지 않는 상황일 뿐이다.   

**ICMP(Internet Control Message Protocol):** ip레벨에서의 통신이 제대로 되고 있는지 확인할 때 사용함.   
Echo Request, Echo Reply가 대표적. 특정 아이피 주소로 Echo Request를 보내면 해당 주소의 컴퓨터가 Echo Reply에서 응답이 오므로, 해당 아이피의 컴퓨터가 잘 작동하는지 알 수 있다.
**ARP(Address Resolution Protocol):** 네트워크 레벨에선 ip주소, 데이터링크 계층에선 Mac주소가 존재하는데 이 둘을 연결해주는 게 ARP이다. 특정 아이피 주소의 컴퓨터가 누군지 응답하라고 보내면 해당 컴퓨터가 맥 주소를 같이 응답한다. 어떤 특정한 아이피 주소와 매칭되는 Mac주소를 알기 위해 사용되는 프로토콜이 ARP이다. 반대는 Reverse ARP이며 맥 주소를 통해 아이피주소를 알 수 있게 만드는 프로토콜이다.   

**DHCP(Dynamic Host Configuration Protocol):** 짧은 시간 동안 아이피 주소를 사용하는 사람들에게 일일이 아이피 주소를 할당한다면 수많은 아이피 주소가 없어지게 되므로 일정 시간동안 특정 아이피 주소를 할당할 수 있게 만든 프로토콜이다.    
무선공유기가 DHCP 서버가 되어서 아이피를 제공.    
맨 처음에는 사용자에겐 아이피 주소가 없기 때문에 발신자 주소에는0.0.0.0이라는 아이피 주소를 보내고 수신자 ip주소에는 255.255.255.255이라는 주소를 보낸다. 그러면 DHCP서버가 여기에 응답을 하는데 DHCP offer이라는 메시지를 보낸다.     
DHCP 서버에 아이피 주소를 보내고 수신자 측엔 주소가 없으므로 255.255.255.255를 보내고 하드웨어 주소인 맥 주소를 같이 보낸다. 그러면 DHCP 클라이언트가 제공된 오퍼 중에서 한 가지를 골라 응답을 한다. 아이피 주소를 할당할 때 사용시간을 지정해주는데 지정시간이 되기 전에 시간 갱신 요청이 이루어지고 시간이 갱신된다.    


**IPv6:** 쓸 수 있는 컴퓨터의 수가 40억개인 기존 IPv4의 한계를 극복하기 위해 만든 새로운 버전.     
앞의 IPv4보다 더욱 간단한 구조를 지니고 있다. 제일 처음의 4비트는 버전 정보를 담고 있으며, 그 다음엔 우선 순위, 흐름 라벨, 길이, TTL등이 나와 있다. 
헤더가 여기서 끝나는 것이 아니라 임의대로 헤더를 만들어 부가적인 기능을 만들 수 있다. 즉 원하는 만큼 헤더를 확장할 수 있다. 새로운 기술을 계속해서 접목할 수 있도록 만든 것이다. 그리고 주소가 128비트로 늘어났다.   